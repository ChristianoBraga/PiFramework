# Î  in a nutshell

Christiano Braga  
Universidade Federal Fluminense  
http://www.ic.uff.br/~cbraga  
\
July 2019  
\
http://github.com/ChristianoBraga/PiFramework

## Introduction

Î  is a simple semantic framework to teach compiler construction
principles. It is comprised of Ï€ IR, a language with
Turing-complete-expressive constructions, and Î  automaton, a
stack-based machine that gives semantics to Î  IR. To construct a
compiler for a language _L_, one needs to define Î  denotations:
functions relating the (abstract) syntax of _L_ with Î  IR
constructions.

## Î  grammar

```
<IR> ::= <Statement>
<OC> ::= <ExpOC> | <CmdOC> | <DecOC> | <AbsOC>
```

## Î  automata

A Î  automaton is a 5-tuple _A = (G, Q, Î´, qâ‚€, F)_, where G is a
context-free grammar, Q is the set of states, qâ‚€ is the initial state,
F âŠ† Q is the set of final states and _ğ›… : L(G)* Ã— L(G)* Ã— Store âŸ¶   Q_,
where _L(G)_ is the language generated by _G_ and _Store_ represents
the memory.

* Grammar _G_ is the result of the composition of Î  IR and Î  opcodes: _G = `<IR>` | `<OC>`_.  
* Elements in a set _S*_ are represented by terms _[sâ‚, sâ‚‚, ..., sáµ¢]_.  
* ğ›…(âˆ…, V, S) âˆˆ F, that is, it denotes an _accepting state_.

## Î  IR expressions

### Grammar
```
<Statement> ::= <Exp> 

<Exp>       ::= <ArithExp> | <BoolExp> 

<ArithExp>  ::= Num(<digits>) | Sum(<Exp> , <Exp> ) | Sub(<Exp>, <Exp>) | 
                Mul(<Exp>, <Exp>) | Div(<Exp>, <Exp>)

<BoolExp>   ::= Boo(<bool>) | Eq(<Exp>, <Exp>) | Lt(<Exp>, <Exp>) | 
                Le(<Exp>, <Exp>) | Gt(<Exp>, <Exp>) | Ge(<Exp>, <Exp>) | 
                And(<Exp>, <Exp>) | Or(<Exp>, <Exp>) | Not(<Exp>) 

<bool>      ::= True | False
```

### Opcodes
```
<ExpOC>     ::= #SUM | #SUB | #MUL | #DIV |   
                #EQ | #LT | #LE | #GT | #GE | #AND | #OR | #NOT
```

### Automaton
    
Recall that _ğ›… : L(G)* Ã— L(G)* Ã— Store âŸ¶   Q_, and let _N, Náµ¢ âˆˆ â„•_ ,
_B, Báµ¢ âˆˆ Bool_, _C, V âˆˆ L(G)*_, _S âˆˆ Store_,

_ğ›…(Num(N) :: C, V, S) = ğ›…(C, N :: V, S)_  
_ğ›…(Sum(Eâ‚, Eâ‚‚) :: C, V, S) = ğ›…(Eâ‚ :: Eâ‚‚ :: #SUM :: C, V, S)_   
_ğ›…(#SUM :: C, Num(Nâ‚) :: Num(Nâ‚‚) :: V, S) = ğ›…(C, Nâ‚ + Nâ‚‚ :: V, S)_

_ğ›…(Sub(Eâ‚, Eâ‚‚) :: C, V, S) = ğ›…(Eâ‚ :: Eâ‚‚ :: #SUB :: C, V, S)_   
_ğ›…(#SUB :: C, Num(Nâ‚) :: Num(Nâ‚‚) :: V, S) = ğ›…(C, Nâ‚ - Nâ‚‚ :: V, S)_

_ğ›…(Mul(Eâ‚, Eâ‚‚) :: C, V, S) = ğ›…(Eâ‚ :: Eâ‚‚ :: #MUL :: C, V, S)_   
_ğ›…(#MUL :: C, Num(Nâ‚) :: Num(Nâ‚‚) :: V, S) = ğ›…(C, Nâ‚ * Nâ‚‚ :: V, S)_

_ğ›…(Div(Eâ‚, Eâ‚‚) :: C, V, S) = ğ›…(Eâ‚ :: Eâ‚‚ :: #MUL :: C, V, S)_   
_ğ›…(#DIV :: C, Num(Nâ‚) :: Num(Nâ‚‚) :: V, S) = ğ›…(C, Nâ‚ / Nâ‚‚ :: V, S) if Nâ‚‚ â‰  0_

_ğ›…(Eq(Eâ‚, Eâ‚‚) :: C, V, S) = ğ›…(Eâ‚ :: Eâ‚‚ :: #EQ :: C, V, S)_   
_ğ›…(#EQ :: C, Boo(Bâ‚) :: Boo(Bâ‚‚) :: V, S) = ğ›…(C, Bâ‚ = Bâ‚‚ :: V, S)_

_ğ›…(Lt(Eâ‚, Eâ‚‚) :: C, V, S) = ğ›…(Eâ‚ :: Eâ‚‚ :: #LT :: C, V, S)_   
_ğ›…(#LT :: C, Num(Nâ‚) :: Num(Nâ‚‚) :: V, S) = ğ›…(C, Nâ‚ < Nâ‚‚ :: V, S)_

_ğ›…(Le(Eâ‚, Eâ‚‚) :: C, V, S) = ğ›…(Eâ‚ :: Eâ‚‚ :: #LE :: C, V, S)_   
_ğ›…(#LE :: C, Num(Nâ‚) :: Num(Nâ‚‚) :: V, S) = ğ›…(C, Nâ‚ â‰¤ Nâ‚‚ :: V, S)_

_ğ›…(Gt(Eâ‚, Eâ‚‚) :: C, V, S) = ğ›…(Eâ‚ :: Eâ‚‚ :: #GT :: C, V, S)_   
_ğ›…(#GT :: C, Num(Nâ‚) :: Num(Nâ‚‚) :: V, S) = ğ›…(C, Nâ‚ > Nâ‚‚ :: V, S)_

_ğ›…(Ge(Eâ‚, Eâ‚‚) :: C, V, S) = ğ›…(Eâ‚ :: Eâ‚‚ :: #GE :: C, V, S)_   
_ğ›…(#GE :: C, Num(Nâ‚) :: Num(Nâ‚‚) :: V, S) = ğ›…(C, Nâ‚ â‰¥ Nâ‚‚ :: V, S)_

_ğ›…(And(Eâ‚, Eâ‚‚) :: C, V, S) = ğ›…(Eâ‚ :: Eâ‚‚ :: #AND :: C, V, S)_   
_ğ›…(#AND :: C, Boo(Bâ‚) :: Boo(Bâ‚‚) :: V, S) = ğ›…(C, Bâ‚ âˆ§ Bâ‚‚ :: V, S)_

_ğ›…(Or(Eâ‚, Eâ‚‚) :: C, V, S) = ğ›…(Eâ‚ :: Eâ‚‚ :: #OR :: C, V, S)_   
_ğ›…(#OR :: C, Boo(Bâ‚) :: Boo(Bâ‚‚) :: V, S) = ğ›…(C, Bâ‚ âˆ¨ Bâ‚‚ :: V, S)_

_ğ›…(Not(E) :: C, V, S) = ğ›…(E :: #NOT :: C, V, S)_   
_ğ›…(#NOT :: C, Boo(True) :: V, S) = ğ›…(C, False :: V, S)_   
_ğ›…(#NOT :: C, Boo(False) :: V, S) = ğ›…(C, True :: V, S)_   

* Notation _h :: ls_ denotes the concatenation of element _h_ with the list _ls_. 

* _C_ represents the _control_ stack. _V_ represents the  _value_ stack. _S_ denotes the memory store.

* On a particular implementation of the Î  Framework, as in Python,
`<digits>` and `<bool>` denote built-in numbers and Boolean values in
the chosen implementation language, such that all arithmetic
operations and Boolean operations, such as `+` and `or`, are defined.
That's why _Náµ¢_ are Natural numbers and _Báµ¢_ are Boolean values.

## Î  IR commands

### Grammar

Commands are language constructions that require a _memory store_ to be evaluated. 

```
<Statement> ::= <Cmd> 

<Exp>       ::= Id(<String>) 
<Cmd>       ::= Nop | Assign(<Id>, <Exp>) | Loop(<BoolExp>, <Cmd>) | 
                CSeq(<Cmd>, <Cmd>) | Cond(<BoolExp>, <Cmd>, <Cmd>)
```

### Opcodes
```
<CmdOC>     ::= #ASSIGN | #LOOP | #COND
```

### Automaton

* A location _l âˆˆ Loc_ denotes a memory cell.
* _Storable_ and _Bindable_ sets denote the data that may be mapped to
  by identifiers and locations on the memory and environment
  respectively.
* _Store = Id â†¦ Storable_, _Env = Loc â†¦ Bindable_, where A â†¦ B denotes the
  finite map between sets A and B.
* _Loc âŠ† Storable_, _â„• âŠ† Storable_, and _â„• âŠ† Bindable_.
* The transition function is _ğ›… : L(G)* Ã— L(G)* Ã— Env Ã— Store âŸ¶   Q_,
  and let _W âˆˆ String_, _C, V âˆˆ L(G)*_, _S âˆˆ Store_, _E âˆˆ Env_, _B âˆˆ
  Bindable_, _l âˆˆ Loc_, _T âˆˆ Storable_, _X âˆˆ `<Exp>`_, _M, Mâ‚, Mâ‚‚ âˆˆ
  `<Cmd>`_,and expression _S' = S/(l â†¦ N)_ means that _S'_ equals to
  _S_ in all indices but _l_ where it is bound to _N_,

_ğ›…(Id(W) :: C, V, E, S) = ğ›…(C, B :: V, E, S)_, **where** _E[W] = l âˆ§ S[l] = B_,

_ğ›…(Assign(W, X) :: C, V, E, S) =  ğ›…(X :: #ASSIGN :: C, W :: V, E, S')_,   
_ğ›…(#ASSIGN :: C, T :: W :: V, E, S) = ğ›…(C, V, E, S')_, **where** _E[W] = l âˆ§ S' = S/(l â†¦ T)_, 

_ğ›…(Loop(X, M) :: C, V, E, S) =  ğ›…(X :: #LOOP :: C, Loop(X, M) :: V, E, S)_,  
_ğ›…(#LOOP :: C, true :: Loop(X, M) :: V, E, S) = ğ›…(M :: Loop(X, M) :: C, V, E, S)_,  
_ğ›…(#LOOP :: C, false :: Loop(X, M) :: V, E, S) = ğ›…(C, V, E, S)_, 

_ğ›…(Cond(X, Mâ‚, Mâ‚‚) :: C, V, E, S) =  ğ›…(X :: #COND :: C, Cond(X, Mâ‚, Mâ‚‚) :: V, E, S)_,  
_ğ›…(#COND :: C, true :: Cond(X, Mâ‚, Mâ‚‚) :: V, E, S) = ğ›…(Mâ‚ :: C, V, E, S)_,  
_ğ›…(#COND :: C, false :: Cond(X, Mâ‚, Mâ‚‚) :: V, E, S) = ğ›…(Mâ‚‚ :: C, V, E, S)_, 

_ğ›…(CSeq(Mâ‚, Mâ‚‚) :: C, V, E, S) = ğ›…(Mâ‚ :: Mâ‚‚ :: C, V, E, S)_.

## Î  IR declarations

### Grammar

* Declarations are statements that create an environment, binding identifiers to (bindable) values.
* In Î  IR, a bindable value is either a Boolean value, an integer or a location. 
* From a syntactic standpoint, all classes are monotonically extended.

```
<Statement> ::= <Dec> 

<Exp>       ::= Ref(<Exp>)> | DeRef(<Id>) | ValRef(<Id>)

<Dec>       ::= Bind(<Id>, <Exp>) | DSeq(<Dec>, <Dec>)

<Cmd>       ::= Blk(<Dec>, <Cmd>) 
```

### Opcodes
```
<DecOC>     ::= #REF | #BLKDEC | #BLKCMD | #BIND | #DSEQ
```

### Automaton

Let _BlockLocs_ = ğ’«(Loc), the transition function be _ğ›… : L(G)* Ã—
L(G)* Ã— Env Ã— Store Ã— BlockLocs âŸ¶   Q_, and let _L, L' âˆˆ BlockLocs_,
_Loc âŠ† Storable_, and _S / L = { l â†¦ T | l â†¦ T âˆˆ S âˆ§ l âˆ‰ L}_, that
is, the store _S_ without the mappings whose locations are in _L_,

_ğ›…(Ref(X) :: C, V, E, S, L) = ğ›…(X :: #REF :: C, V, E, S, L)_,   
_ğ›…(#REF :: C, T :: V, E, S, L) = ğ›…(C, l :: V, E, S', L')_, **where** _S' = S âˆª [l â†¦ T], l âˆ‰ S, L' = L âˆª {l}_, 

_ğ›…(DeRef(Id(W)) :: C, V, E, S, L) = ğ›…(C, l :: V, E, S, L)_, **where** _l = E[W]_,  

_ğ›…(ValRef(Id(W)) :: C, V, E, S, L) = ğ›…(C, T :: V, E, S, L)_, **where** _T = S[S[E[W]]]_,  

_ğ›…(Bind(Id(W), X) :: C, V, E, S, L) = ğ›…(X :: #BIND :: C, W :: V, E, S, L)_,   
_ğ›…(#BIND :: C, B :: W :: E' :: V, E, S, L) = ğ›…(C, ({W â†¦ B} âˆª E') :: V, E, S, L)_, **where** _E' âˆˆ Env_,  
_ğ›…(#BIND :: C, B :: W :: H :: V, E, S, L) = ğ›…(C, {W â†¦ B} :: H :: V, E, S, L)_, **where** _H âˆ‰ Env_,  

_ğ›…(DSeq(Dâ‚, Dâ‚‚), X) :: C, V, E, S, L) = ğ›…(Dâ‚ :: Dâ‚‚ :: C, V, E, S, L)_, 

_ğ›…(Blk(D, M) :: C, V, E, S, L) = ğ›…(D :: #BLKDEC :: M :: #BLKCMD :: C, L :: V, E, S, âˆ…)_,   
_ğ›…(#BLKDEC :: C, E' :: V, E, S, L) = ğ›…(C, E :: V, E / E', S, L)_,   
_ğ›…(#BLKCMD :: C, E :: L :: V, E', S, L') = ğ›…(C, V, E, S', L)_, **where** _S' = S / L'_.

## Î  IR abstractions

### Grammar

Abstractions extend Bindables by allowing a name to be bound to a list
of formal parameters, a list of identifiers, and a block in the
environment.  Such names can be called and applied to actual
parameters, a list of expressions.

```
<Dec>     ::= Bind(<Id>, <Abs>) 

<Abs>     ::= Abs(<Formals>, <Blk>) 

<Formals> ::= <Id>*

<Cmd>     ::= Call(<Id>, <Actuals>)

<Actuals> ::= <Exp>*
```

### Automaton

#### Closures

We chose a static binding semantics for abstractions. Therefore, we
interpret abstractions as _closures_ formed by an abstraction together
with its declaration environment which defines the context in which
the abstraction will be evaluated.

_Closure : Formals Ã— Blk Ã— Env âŸ¶   Bindable_ 

#### Abstractions

Let _F âˆˆ Formals_, _B âˆˆ Blk_, _I âˆˆ Id_, _A âˆˆ Actuals_, _Váµ¢ âˆˆ Value_, _1 â‰¤ i â‰¤ u_, _u âˆˆ â„•_,  

_ğ›…(Abs(F, B) :: C, V, E, S, L) = ğ›…(C, Closure(F, B, E) :: V, E, S, L)_   

_ğ›…(Call(I, [Xâ‚, Xâ‚‚, ..., Xáµ¤])) :: C, V, E, S, L)_ =   
_ğ›…(Xáµ¤ :: Xáµ¤â‚‹â‚ :: ... :: Xâ‚ :: #CALL(I, u) :: C, V, E, S, L)_   
_ğ›…(#CALL(I, u) ::C, Vâ‚ :: Vâ‚‚ :: ... :: Váµ¤ :: V, E, S, L) =_  
    _ğ›…(B :: #BLKCMD :: C, E :: V, E', S, L)_   
**where** E = {I â†¦ Closure(F, B, Eâ‚)} âˆª Eâ‚‚,
	      E'= E / Eâ‚ / match(F, [Vâ‚, Vâ‚‚, ..., Váµ¤])

_match : Id* Ã— Values* âŸ¶   Env_  
_match(fl, al) = **if** |fl| â‰  |al| **than** {} **else** match-aux(fl, al, {})_

_match-aux : Id* Ã— Values* Ã— Env âŸ¶   Env_   
_match-aux([], [], E) = E_    
_match-aux(f, a, E) = {f â†¦ a} âˆª E_  
_match-aux(f :: fl, a :: al, E) = match-aux(fl, al, {f â†¦ a} âˆª E)_


## Î  IR recursive abstractions

### Grammar

```
<Dec>       ::= `Rbnd'(<Id>, <Abs>) 
```

### Automaton

#### Recursive closures

In the context of _static binding_ semantics for abstractions, in a call
to a recursive function, the evaluation of identifiers needs to be
"reminded" about the binding of the function name to a closure.

_Rec : Formals Ã— Blk Ã— Env Ã— Env âŸ¶   Bindable_  
_unfold : Env âŸ¶   Env_  
_recloseâ‚‘_ : Env âŸ¶   Env_  

_unfold(E) = recloseâ‚‘(e)_  
_recloseâ‚‘(I â†¦ Closure(F, B, Eâ€²)) = (I â†¦ Rec(F, B, Eâ€², E))_  
_recloseâ‚‘(I â†¦ Rec(F, B, Eâ€², Eâ€²â€²)) = (I â†¦ Rec(F, B, Eâ€², E))_  
_recloseâ‚‘(I â†¦ v) = (I â†¦ v) if v != Closure(F, B, E)_   
_recloseâ‚‘(Eâ‚ âˆª Eâ‚‚) = recloseâ‚‘(Eâ‚) âˆª recloseâ‚‘(Eâ‚‚)_  
_recloseâ‚‘(âˆ…) = âˆ…_  

#### Recursive abstractions 

_Î´(Rbnd(I, Abs(F, B)) :: C, V, E, S, L) = Î´(C, unfold(I â†¦ Closure(F, B, E)) :: V, E, S, L)_  
_Î´(#CALL(I, u) :: C, Vâ‚ :: Vâ‚‚ :: ... :: Váµ¤ :: V, E, S, L) = Î´(B :: #BLKCMD :: C, E :: V, Eâ€², S, L)_  
**where** _E = {I â†¦ Rec(F, B, Eâ‚, Eâ‚‚)} âˆª Eâ‚ƒ_  
         _E' = E / Eâ‚ / unfold(Eâ‚‚) / match(F, [Vâ‚, Vâ‚‚, ..., Váµ¤])_  
