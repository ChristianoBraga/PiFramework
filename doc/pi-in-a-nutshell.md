# Π in a nutshell

Christiano Braga  
Universidade Federal Fluminense  
http://www.ic.uff.br/~cbraga  
\
March 2019  
\
http://github.com/ChristianoBraga/PiFramework

## Introduction

Π is a simple semantic framework to teach compiler construction principles. It is comprised of π IR, a language with Turing-complete-expressive constructions, and π automaton, a stack-based machine that gives semantics to π IR. To construct a compiler for a language _L_, one needs to define π denotations: functions relating the (abstract) syntax of _L_ with π IR constructions.

## π grammar

```
<IR> ::= <Statement>
<OC> ::= <ExpOC> | <CmdOC> | <DecOC> | <AbsOC>
```

## π automata

A π automaton is a 5-tuple _A = (G, Q, δ, q₀, F)_, where G is a context-free grammar, Q is the set of states, q₀ is the initial state, F ⊆ Q is the set of final states and
_δ : L(G)* × L(G)* × Store → Q_, where _L(G)_ is the language generated by _G_ and _Store_ represents the memory. 

* Grammar _G_ is the result of the composition of π IR and π opcodes: _G = `<IR>` | `<OC>`_.

* Elements in a set _S*_ are represented by terms _[s₁, s₂, ..., sᵢ]_.

* δ(∅, V, S) denotes an _accepting state_.

## π IR expressions

### Grammar
```
<Statement> ::= <Exp> 

<Exp>       ::= <ArithExp> | <BoolExp> 

<ArithExp>  ::= Num(<digits>) | Sum(<Exp> , <Exp> ) | Sub(<Exp>, <Exp>) | 
                Mul(<Exp>, <Exp>) | Div(<Exp>, <Exp>)

<BoolExp>   ::= Boo(<bool>) | Eq(<Exp>, <Exp>) | Lt(<Exp>, <Exp>) | 
                Le(<Exp>, <Exp>) | Gt(<Exp>, <Exp>) | Ge(<Exp>, <Exp>) | 
                And(<Exp>, <Exp>) | Or(<Exp>, <Exp>) | Not(<Exp>) 

<bool>      ::= True | False
```

### Opcodes
```
<ExpOC>     ::= #SUM | #SUB | #MUL | #DIV |   
                #EQ | #LT | #LE | #GT | #GE | #AND | #OR | #NOT
```

### Automaton
    
Recall that _δ : L(G)* × L(G)* × Store → Q_, and let _N, Nᵢ ∈ ℕ_ , _B, Bᵢ ∈ Bool_, _C, V ∈ L(G)*_, _S ∈ Store_,

_δ(Num(N) :: C, V, S) = δ(C, N :: V, S)_  

_δ(Sum(E₁, E₂) :: C, V, S) = δ(E₁ :: E₂ :: #SUM :: C, V, S)_   
_δ(#SUM :: C, Num(N₁) :: Num(N₂) :: V, S) = δ(C, N₁ + N₂ :: V, S)_

_δ(Sub(E₁, E₂) :: C, V, S) = δ(E₁ :: E₂ :: #SUB :: C, V, S)_   
_δ(#SUB :: C, Num(N₁) :: Num(N₂) :: V, S) = δ(C, N₁ - N₂ :: V, S)_

_δ(Mul(E₁, E₂) :: C, V, S) = δ(E₁ :: E₂ :: #MUL :: C, V, S)_   
_δ(#MUL :: C, Num(N₁) :: Num(N₂) :: V, S) = δ(C, N₁ * N₂ :: V, S)_

_δ(Div(E₁, E₂) :: C, V, S) = δ(E₁ :: E₂ :: #MUL :: C, V, S)_   
_δ(#DIV :: C, Num(N₁) :: Num(N₂) :: V, S) = δ(C, N₁ / N₂ :: V, S) if N₂ ≠ 0_

_δ(Eq(E₁, E₂) :: C, V, S) = δ(E₁ :: E₂ :: #EQ :: C, V, S)_   
_δ(#EQ :: C, Boo(B₁) :: Boo(B₂) :: V, S) = δ(C, B₁ = B₂ :: V, S)_

_δ(Lt(E₁, E₂) :: C, V, S) = δ(E₁ :: E₂ :: #LT :: C, V, S)_   
_δ(#LT :: C, Num(N₁) :: Num(N₂) :: V, S) = δ(C, N₁ < N₂ :: V, S)_

_δ(Le(E₁, E₂) :: C, V, S) = δ(E₁ :: E₂ :: #LE :: C, V, S)_   
_δ(#LE :: C, Num(N₁) :: Num(N₂) :: V, S) = δ(C, N₁ ≤ N₂ :: V, S)_

_δ(Gt(E₁, E₂) :: C, V, S) = δ(E₁ :: E₂ :: #GT :: C, V, S)_   
_δ(#GT :: C, Num(N₁) :: Num(N₂) :: V, S) = δ(C, N₁ > N₂ :: V, S)_

_δ(Ge(E₁, E₂) :: C, V, S) = δ(E₁ :: E₂ :: #GE :: C, V, S)_   
_δ(#GE :: C, Num(N₁) :: Num(N₂) :: V, S) = δ(C, N₁ ≥ N₂ :: V, S)_

_δ(And(E₁, E₂) :: C, V, S) = δ(E₁ :: E₂ :: #AND :: C, V, S)_   
_δ(#AND :: C, Boo(B₁) :: Boo(B₂) :: V, S) = δ(C, B₁ ∧ B₂ :: V, S)_

_δ(Or(E₁, E₂) :: C, V, S) = δ(E₁ :: E₂ :: #OR :: C, V, S)_   
_δ(#OR :: C, Boo(B₁) :: Boo(B₂) :: V, S) = δ(C, B₁ ∨ B₂ :: V, S)_

_δ(Not(E) :: C, V, S) = δ(E :: #NOT :: C, V, S)_   
_δ(#NOT :: C, Boo(True) :: V, S) = δ(C, False :: V, S)_   
_δ(#NOT :: C, Boo(False) :: V, S) = δ(C, True :: V, S)_   

* Notation _h :: ls_ denotes the concatenation of element _h_ with the list _ls_. 

* _C_ represents the _control_ stack. _V_ represents the  _value_ stack. _S_ denotes the memory store.

* On a particular implementation of the π Framework, as in Python, `<digits>` and `<bool>`
denote built-in numbers and Boolean values in the chosen implementation language, such that all arithmetic operations and Boolean operations, such as `+` and `or`, are defined.
That's why _Nᵢ_ are Natural numbers and _Bᵢ_ are Boolean values.

## π IR commands

### Grammar

Commands are language constructions that require a _memory store_ to be evaluated. 

```
<Statement> ::= <Cmd> 

<Exp>       ::= Id(<String>) 
<Cmd>       ::= Nop | Assign(<Id>, <Exp>) | Loop(<BoolExp>, <Cmd>) | 
                CSeq(<Cmd>, <Cmd>) | Cond(<BoolExp>, <Cmd>, <Cmd>)
```

### Opcodes
```
<CmdOC>     ::= #ASSIGN | #LOOP | #COND
```

### Automaton

* A location _l ∈ Loc_ denotes a memory cell.
* _Storable_ and _Bindable_ sets denote the data that may be mapped to by identifiers and locations on the memory and environment respectively. 
* _Store = Id ↦ Storable_, _Env = Loc ↦ Bindable_, _Loc ⊆ Store_, _ℕ ⊆ Loc_, _ℕ ⊆ Bindable_.
* The transition function is _δ : L(G)* × L(G)* × Env × Store → Q_, and let _W ∈ String_,  _C, V ∈ L(G)*_, _S ∈ Store_, _E ∈ Env_, _B ∈ Bindable_, _l ∈ Loc_, _T ∈ Storable_, _X ∈ `<Exp>`_, _M, M₁, M₂ ∈ `<Cmd>`_,and expression _S' = S/[l ↦ N]_ means that _S'_ equals to _S_ in all indices but _I_ that is bound to _N_,

_δ(Id(W) :: C, V, E, S) = δ(C, B :: V, E, S)_, where _E[W] = l ∧ S[l] = B_,

_δ(Assign(W, X) :: C, V, E, S) =  δ(X :: #ASSIGN :: C, W :: V, E, S')_,   
_δ(#ASSIGN :: C, T :: W :: V, E, S) = δ(C, V, E, S')_, where _E[W] = l ∧ S' = S/[l ↦ T]_, 

_δ(Loop(X, M) :: C, V, E, S) =  δ(X :: #LOOP :: C, Loop(X, M) :: V, E, S)_,  
_δ(#LOOP :: C, Boo(true) :: Loop(X, M) :: V, E, S) = δ(M :: Loop(X, M) :: C, V, E, S)_,  
_δ(#LOOP :: C, Boo(false) :: Loop(X, M) :: V, E, S) = δ(C, V, E, S)_, 

_δ(Cond(X, M₁, M₂) :: C, V, E, S) =  δ(X :: #COND :: C, Cond(X, M₁, M₂) :: V, E, S)_,  
_δ(#COND :: C, Boo(true) :: Cond(X, M₁, M₂) :: V, E, S) = δ(M₁ :: C, V, E, S)_,  
_δ(#COND :: C, Boo(false) :: Cond(X, M₁, M₂) :: V, E, S) = δ(M₂ :: C, V, E, S)_, 

_δ(CSeq(M₁, M₂) :: C, V, E, S) = δ(M₁ :: M₂ :: C, V, E, S)_.

## π IR declarations

### Grammar

* Declarations are statements that create an environment, binding identifiers to (bindable) values.
* In π IR, a bindable value is either a Boolean value, an integer or a location. 
* From a syntactic standpoint, all classes are monotonically extended.

```
<Statement> ::= <Dec> 

<Exp>       ::= Ref(<Exp>)> | DeRef(<Id>) | ValRef(<Id>)

<Dec>       ::= Bind(<Id>, <Exp>) | DSeq(<Dec>, <Dec>)

<Cmd>       ::= Blk(<Dec>, <Cmd>) 
```

### Opcodes
```
<DecOC>     ::= #REF | #BLKDEC | #BLKCMD | #BIND | #DSEQ
```

### Automaton

Let _BlockLocs_ = 2ᴸᴼᶜ, the transition function be _δ : L(G)* × L(G)* × Env × Store × BlockLocs → Q_, and
let _L, L' ∈ BlockLocs_, _Loc_ ⊆ Storable_, and _S / L_ mean the store _S_ without the locations in _L_,

_δ(Ref(X) :: C, V, E, S, L) = δ(X :: #REF :: C, V, E, S, L)_,   
_δ(#REF :: C, T :: V, E, S, L) = δ(C, l :: V, E, S', L')_, where _S' = S ∪ [l ↦ T], l ∉ S, L' = L ∪ {l}_, 

_δ(DeRef(Id(W)) :: C, V, E, S, L) = δ(C, l :: V, E, S, L)_, where _l = E[W]_,  

_δ(ValRef(Id(W)) :: C, V, E, S, L) = δ(C, T :: V, E, S, L)_, where _T = S[S[E[W]]]_,  

_δ(Bind(Id(W), X) :: C, V, E, S, L) = δ(X :: #BIND :: C, W :: V, E, S, L)_,   
_δ(#BIND :: C, B :: W :: E' :: V, E, S, L) = δ(C, ([W ↦ B] ∪ E') :: V, E, S, L)_, where _E' ∈ Env_,  
_δ(#BIND :: C, B :: W :: H :: V, E, S, L) = δ(C, [W ↦ B] :: H :: V, E, S, L)_, where _H ∉ Env_,  

_δ(DSeq(D₁, D₂), X) :: C, V, E, S, L) = δ(D₁ :: D₂ :: C, V, E, S, L)_, 

_δ(Blk(D, M) :: C, V, E, S, L) = δ(D :: #BLKDEC :: M :: #BLKCMD :: C, L :: V, E, S, ∅)_,   
_δ(#BLKDEC :: C, E' :: V, E, S, L) = δ(C, E :: V, E / E', S, L)_,   
_δ(#BLKCMD :: C, E :: L :: V, E', S, L') = δ(C, V, E, S', L)_, where _S' = S / L_.

## π IR abstractions

### Grammar

Abstractions extend Bindables by allowing a name to be bound to a list of formal parameters, a list of identifiers, and a block in the environment.
Such names can be called and applied to actual parameters, a list of expressions.
```
<Dec>     ::= Bind(<Id>, <Abs>) 

<Abs>     ::= Abs(<Formals>, <Blk>) 

<Formals> ::= <Id>*

<Cmd>     ::= Call(<Id>, <Actuals>)

<Actuals> ::= <Exp>*
```

### Automaton

#### Closures

We chose a static binding semantics for abstractions. Therefore, we interpret abstractions as _closures formed by an abstraction together with its declaration environment which defines the context in which the abstraction will be evaluated.

_Closure : Formals × Blk × Env → Bindable_

#### Abstractions

Let _F ∈ Formals_, _B ∈ Blk_, _I ∈ Id_, _A ∈ Actuals_, _Vᵢ ∈ Value_, _1 ≤ i ≤ n_, _n ∈ ℕ_,  

_δ(Abs(F, B) :: C, V, E, S, L) = δ(C, Closure(F, B, E) :: V, E, S, L)_   

_δ(Call(I, [X₁, X₂, ..., Xn])) :: C, V, E, S, L) =   
    δ(Xn :: Xn-1 :: ... :: X_1 :: #CALL(I, n) :: C, V, E, S, L)_   
_δ(#CALL(I, n) ::C, [V₁, V₂, ..., Vn] :: V, [I ↦ Closure(F, B, E₁)] E₂, S, L) =_  
    _δ(B :: #BLKCMD :: C, E₂ :: V, (E₁ / match(F, [V₁, V₂, ..., Vn])), S, L)_   

_match : Id* × Values* → Env_  
_match(fl, al) = if |fl| ≠ |al| than {} else match-aux(fl, al, {})_   
_match-aux : Id* × Values* × Env → Env_   
_match-aux([], [], E) = E_    
_match-aux(f, a, E) = {f ↦ a} E_  
_match-aux(f :: fl, a :: al, E) = match-aux(fl), al, {f ↦ a} E)_   
