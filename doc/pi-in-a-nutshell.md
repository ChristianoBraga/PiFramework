# Œ† in a nutshell

Christiano Braga  
Universidade Federal Fluminense  
http://www.ic.uff.br/~cbraga  
\
March 2019  
\
http://github.com/ChristianoBraga/PiFramework

## Introduction

Œ† is a simple semantic framework to teach compiler construction principles. It is comprised of œÄ IR, a language with Turing-complete-expressive constructions, and Œ† automaton, a stack-based machine that gives semantics to Œ† IR. To construct a compiler for a language _L_, one needs to define Œ† denotations: functions relating the (abstract) syntax of _L_ with Œ† IR constructions.

## Œ† grammar

```
<IR> ::= <Statement>
<OC> ::= <ExpOC> | <CmdOC> | <DecOC> | <AbsOC>
```

## Œ† automata

A Œ† automaton is a 5-tuple _A = (G, Q, Œ¥, q‚ÇÄ, F)_, where G is a context-free grammar, Q is the set of states, q‚ÇÄ is the initial state, F ‚äÜ Q is the set of final states and
_Œ¥ : L(G)* √ó L(G)* √ó Store ‚Üí Q_, where _L(G)_ is the language generated by _G_ and _Store_ represents the memory. 

* Grammar _G_ is the result of the composition of Œ† IR and Œ† opcodes: _G = `<IR>` | `<OC>`_.  
* Elements in a set _S*_ are represented by terms _[s‚ÇÅ, s‚ÇÇ, ..., s·µ¢]_.  
* Œ¥(‚àÖ, V, S) denotes an _accepting state_.

## Œ† IR expressions

### Grammar
```
<Statement> ::= <Exp> 

<Exp>       ::= <ArithExp> | <BoolExp> 

<ArithExp>  ::= Num(<digits>) | Sum(<Exp> , <Exp> ) | Sub(<Exp>, <Exp>) | 
                Mul(<Exp>, <Exp>) | Div(<Exp>, <Exp>)

<BoolExp>   ::= Boo(<bool>) | Eq(<Exp>, <Exp>) | Lt(<Exp>, <Exp>) | 
                Le(<Exp>, <Exp>) | Gt(<Exp>, <Exp>) | Ge(<Exp>, <Exp>) | 
                And(<Exp>, <Exp>) | Or(<Exp>, <Exp>) | Not(<Exp>) 

<bool>      ::= True | False
```

### Opcodes
```
<ExpOC>     ::= #SUM | #SUB | #MUL | #DIV |   
                #EQ | #LT | #LE | #GT | #GE | #AND | #OR | #NOT
```

### Automaton
    
Recall that _Œ¥ : L(G)* √ó L(G)* √ó Store ‚Üí Q_, and let _N, N·µ¢ ‚àà ‚Ñï_ , _B, B·µ¢ ‚àà Bool_, _C, V ‚àà L(G)*_, _S ‚àà Store_,

```math
_Œ¥(Num(N) :: C, V, S) = Œ¥(C, N :: V, S)_  
_Œ¥(Sum(E‚ÇÅ, E‚ÇÇ) :: C, V, S) = Œ¥(E‚ÇÅ :: E‚ÇÇ :: #SUM :: C, V, S)_   
_Œ¥(#SUM :: C, Num(N‚ÇÅ) :: Num(N‚ÇÇ) :: V, S) = Œ¥(C, N‚ÇÅ + N‚ÇÇ :: V, S)_

_Œ¥(Sub(E‚ÇÅ, E‚ÇÇ) :: C, V, S) = Œ¥(E‚ÇÅ :: E‚ÇÇ :: #SUB :: C, V, S)_   
_Œ¥(#SUB :: C, Num(N‚ÇÅ) :: Num(N‚ÇÇ) :: V, S) = Œ¥(C, N‚ÇÅ - N‚ÇÇ :: V, S)_

_Œ¥(Mul(E‚ÇÅ, E‚ÇÇ) :: C, V, S) = Œ¥(E‚ÇÅ :: E‚ÇÇ :: #MUL :: C, V, S)_   
_Œ¥(#MUL :: C, Num(N‚ÇÅ) :: Num(N‚ÇÇ) :: V, S) = Œ¥(C, N‚ÇÅ * N‚ÇÇ :: V, S)_

_Œ¥(Div(E‚ÇÅ, E‚ÇÇ) :: C, V, S) = Œ¥(E‚ÇÅ :: E‚ÇÇ :: #MUL :: C, V, S)_   
_Œ¥(#DIV :: C, Num(N‚ÇÅ) :: Num(N‚ÇÇ) :: V, S) = Œ¥(C, N‚ÇÅ / N‚ÇÇ :: V, S) if N‚ÇÇ ‚â† 0_

_Œ¥(Eq(E‚ÇÅ, E‚ÇÇ) :: C, V, S) = Œ¥(E‚ÇÅ :: E‚ÇÇ :: #EQ :: C, V, S)_   
_Œ¥(#EQ :: C, Boo(B‚ÇÅ) :: Boo(B‚ÇÇ) :: V, S) = Œ¥(C, B‚ÇÅ = B‚ÇÇ :: V, S)_

_Œ¥(Lt(E‚ÇÅ, E‚ÇÇ) :: C, V, S) = Œ¥(E‚ÇÅ :: E‚ÇÇ :: #LT :: C, V, S)_   
_Œ¥(#LT :: C, Num(N‚ÇÅ) :: Num(N‚ÇÇ) :: V, S) = Œ¥(C, N‚ÇÅ < N‚ÇÇ :: V, S)_

_Œ¥(Le(E‚ÇÅ, E‚ÇÇ) :: C, V, S) = Œ¥(E‚ÇÅ :: E‚ÇÇ :: #LE :: C, V, S)_   
_Œ¥(#LE :: C, Num(N‚ÇÅ) :: Num(N‚ÇÇ) :: V, S) = Œ¥(C, N‚ÇÅ ‚â§ N‚ÇÇ :: V, S)_

_Œ¥(Gt(E‚ÇÅ, E‚ÇÇ) :: C, V, S) = Œ¥(E‚ÇÅ :: E‚ÇÇ :: #GT :: C, V, S)_   
_Œ¥(#GT :: C, Num(N‚ÇÅ) :: Num(N‚ÇÇ) :: V, S) = Œ¥(C, N‚ÇÅ > N‚ÇÇ :: V, S)_

_Œ¥(Ge(E‚ÇÅ, E‚ÇÇ) :: C, V, S) = Œ¥(E‚ÇÅ :: E‚ÇÇ :: #GE :: C, V, S)_   
_Œ¥(#GE :: C, Num(N‚ÇÅ) :: Num(N‚ÇÇ) :: V, S) = Œ¥(C, N‚ÇÅ ‚â• N‚ÇÇ :: V, S)_

_Œ¥(And(E‚ÇÅ, E‚ÇÇ) :: C, V, S) = Œ¥(E‚ÇÅ :: E‚ÇÇ :: #AND :: C, V, S)_   
_Œ¥(#AND :: C, Boo(B‚ÇÅ) :: Boo(B‚ÇÇ) :: V, S) = Œ¥(C, B‚ÇÅ ‚àß B‚ÇÇ :: V, S)_

_Œ¥(Or(E‚ÇÅ, E‚ÇÇ) :: C, V, S) = Œ¥(E‚ÇÅ :: E‚ÇÇ :: #OR :: C, V, S)_   
_Œ¥(#OR :: C, Boo(B‚ÇÅ) :: Boo(B‚ÇÇ) :: V, S) = Œ¥(C, B‚ÇÅ ‚à® B‚ÇÇ :: V, S)_

_Œ¥(Not(E) :: C, V, S) = Œ¥(E :: #NOT :: C, V, S)_   
_Œ¥(#NOT :: C, Boo(True) :: V, S) = Œ¥(C, False :: V, S)_   
_Œ¥(#NOT :: C, Boo(False) :: V, S) = Œ¥(C, True :: V, S)_   
```
* Notation _h :: ls_ denotes the concatenation of element _h_ with the list _ls_. 

* _C_ represents the _control_ stack. _V_ represents the  _value_ stack. _S_ denotes the memory store.

* On a particular implementation of the Œ† Framework, as in Python, `<digits>` and `<bool>`
denote built-in numbers and Boolean values in the chosen implementation language, such that all arithmetic operations and Boolean operations, such as `+` and `or`, are defined.
That's why _N·µ¢_ are Natural numbers and _B·µ¢_ are Boolean values.

## Œ† IR commands

### Grammar

Commands are language constructions that require a _memory store_ to be evaluated. 

```
<Statement> ::= <Cmd> 

<Exp>       ::= Id(<String>) 
<Cmd>       ::= Nop | Assign(<Id>, <Exp>) | Loop(<BoolExp>, <Cmd>) | 
                CSeq(<Cmd>, <Cmd>) | Cond(<BoolExp>, <Cmd>, <Cmd>)
```

### Opcodes
```
<CmdOC>     ::= #ASSIGN | #LOOP | #COND
```

### Automaton

* A location _l ‚àà Loc_ denotes a memory cell.
* _Storable_ and _Bindable_ sets denote the data that may be mapped to by identifiers and locations on the memory and environment respectively. 
* _Store = Id ‚Ü¶ Storable_, _Env = Loc ‚Ü¶ Bindable_, _Loc ‚äÜ Store_, _‚Ñï ‚äÜ Loc_, _‚Ñï ‚äÜ Bindable_.
* The transition function is _Œ¥ : L(G)* √ó L(G)* √ó Env √ó Store ‚Üí Q_, and let _W ‚àà String_,  _C, V ‚àà L(G)*_, _S ‚àà Store_, _E ‚àà Env_, _B ‚àà Bindable_, _l ‚àà Loc_, _T ‚àà Storable_, _X ‚àà `<Exp>`_, _M, M‚ÇÅ, M‚ÇÇ ‚àà `<Cmd>`_,and expression _S' = S/[l ‚Ü¶ N]_ means that _S'_ equals to _S_ in all indices but _I_ that is bound to _N_,

_Œ¥(Id(W) :: C, V, E, S) = Œ¥(C, B :: V, E, S)_, where _E[W] = l ‚àß S[l] = B_,

_Œ¥(Assign(W, X) :: C, V, E, S) =  Œ¥(X :: #ASSIGN :: C, W :: V, E, S')_,   
_Œ¥(#ASSIGN :: C, T :: W :: V, E, S) = Œ¥(C, V, E, S')_, where _E[W] = l ‚àß S' = S/[l ‚Ü¶ T]_, 

_Œ¥(Loop(X, M) :: C, V, E, S) =  Œ¥(X :: #LOOP :: C, Loop(X, M) :: V, E, S)_,  
_Œ¥(#LOOP :: C, Boo(true) :: Loop(X, M) :: V, E, S) = Œ¥(M :: Loop(X, M) :: C, V, E, S)_,  
_Œ¥(#LOOP :: C, Boo(false) :: Loop(X, M) :: V, E, S) = Œ¥(C, V, E, S)_, 

_Œ¥(Cond(X, M‚ÇÅ, M‚ÇÇ) :: C, V, E, S) =  Œ¥(X :: #COND :: C, Cond(X, M‚ÇÅ, M‚ÇÇ) :: V, E, S)_,  
_Œ¥(#COND :: C, Boo(true) :: Cond(X, M‚ÇÅ, M‚ÇÇ) :: V, E, S) = Œ¥(M‚ÇÅ :: C, V, E, S)_,  
_Œ¥(#COND :: C, Boo(false) :: Cond(X, M‚ÇÅ, M‚ÇÇ) :: V, E, S) = Œ¥(M‚ÇÇ :: C, V, E, S)_, 

_Œ¥(CSeq(M‚ÇÅ, M‚ÇÇ) :: C, V, E, S) = Œ¥(M‚ÇÅ :: M‚ÇÇ :: C, V, E, S)_.

## Œ† IR declarations

### Grammar

* Declarations are statements that create an environment, binding identifiers to (bindable) values.
* In Œ† IR, a bindable value is either a Boolean value, an integer or a location. 
* From a syntactic standpoint, all classes are monotonically extended.

```
<Statement> ::= <Dec> 

<Exp>       ::= Ref(<Exp>)> | DeRef(<Id>) | ValRef(<Id>)

<Dec>       ::= Bind(<Id>, <Exp>) | DSeq(<Dec>, <Dec>)

<Cmd>       ::= Blk(<Dec>, <Cmd>) 
```

### Opcodes
```
<DecOC>     ::= #REF | #BLKDEC | #BLKCMD | #BIND | #DSEQ
```

### Automaton

Let _BlockLocs_ = ùí´(Loc), the transition function be _Œ¥ : L(G)* √ó L(G)* √ó Env √ó Store √ó BlockLocs ‚Üí Q_, and
let _L, L' ‚àà BlockLocs_, _Loc_ ‚äÜ Storable_, and _S / L_ mean the store _S_ without the locations in _L_,

_Œ¥(Ref(X) :: C, V, E, S, L) = Œ¥(X :: #REF :: C, V, E, S, L)_,   
_Œ¥(#REF :: C, T :: V, E, S, L) = Œ¥(C, l :: V, E, S', L')_, where _S' = S ‚à™ [l ‚Ü¶ T], l ‚àâ S, L' = L ‚à™ {l}_, 

_Œ¥(DeRef(Id(W)) :: C, V, E, S, L) = Œ¥(C, l :: V, E, S, L)_, where _l = E[W]_,  

_Œ¥(ValRef(Id(W)) :: C, V, E, S, L) = Œ¥(C, T :: V, E, S, L)_, where _T = S[S[E[W]]]_,  

_Œ¥(Bind(Id(W), X) :: C, V, E, S, L) = Œ¥(X :: #BIND :: C, W :: V, E, S, L)_,   
_Œ¥(#BIND :: C, B :: W :: E' :: V, E, S, L) = Œ¥(C, ([W ‚Ü¶ B] ‚à™ E') :: V, E, S, L)_, where _E' ‚àà Env_,  
_Œ¥(#BIND :: C, B :: W :: H :: V, E, S, L) = Œ¥(C, [W ‚Ü¶ B] :: H :: V, E, S, L)_, where _H ‚àâ Env_,  

_Œ¥(DSeq(D‚ÇÅ, D‚ÇÇ), X) :: C, V, E, S, L) = Œ¥(D‚ÇÅ :: D‚ÇÇ :: C, V, E, S, L)_, 

_Œ¥(Blk(D, M) :: C, V, E, S, L) = Œ¥(D :: #BLKDEC :: M :: #BLKCMD :: C, L :: V, E, S, ‚àÖ)_,   
_Œ¥(#BLKDEC :: C, E' :: V, E, S, L) = Œ¥(C, E :: V, E / E', S, L)_,   
_Œ¥(#BLKCMD :: C, E :: L :: V, E', S, L') = Œ¥(C, V, E, S', L)_, where _S' = S / L_.

## Œ† IR abstractions

### Grammar

Abstractions extend Bindables by allowing a name to be bound to a list of formal parameters, a list of identifiers, and a block in the environment.
Such names can be called and applied to actual parameters, a list of expressions.
```
<Dec>     ::= Bind(<Id>, <Abs>) 

<Abs>     ::= Abs(<Formals>, <Blk>) 

<Formals> ::= <Id>*

<Cmd>     ::= Call(<Id>, <Actuals>)

<Actuals> ::= <Exp>*
```

### Automaton

#### Closures

We chose a static binding semantics for abstractions. Therefore, we interpret abstractions as _closures_ formed by an abstraction together with its declaration environment which defines the context in which the abstraction will be evaluated.

_Closure : Formals √ó Blk √ó Env ‚Üí Bindable_

#### Abstractions

Let _F ‚àà Formals_, _B ‚àà Blk_, _I ‚àà Id_, _A ‚àà Actuals_, _V·µ¢ ‚àà Value_, _1 ‚â§ i ‚â§ n_, _n ‚àà ‚Ñï_,  

_Œ¥(Abs(F, B) :: C, V, E, S, L) = Œ¥(C, Closure(F, B, E) :: V, E, S, L)_   

_Œ¥(Call(I, [X‚ÇÅ, X‚ÇÇ, ..., Xn])) :: C, V, E, S, L) =   
    Œ¥(Xn :: Xn-1 :: ... :: X_1 :: #CALL(I, n) :: C, V, E, S, L)_   
_Œ¥(#CALL(I, n) ::C, [V‚ÇÅ, V‚ÇÇ, ..., Vn] :: V, [I ‚Ü¶ Closure(F, B, E‚ÇÅ)] E‚ÇÇ, S, L) =_  
    _Œ¥(B :: #BLKCMD :: C, E‚ÇÇ :: V, (E‚ÇÅ / match(F, [V‚ÇÅ, V‚ÇÇ, ..., Vn])), S, L)_   

_match : Id* √ó Values* ‚Üí Env_  
_match(fl, al) = if |fl| ‚â† |al| than {} else match-aux(fl, al, {})_   
_match-aux : Id* √ó Values* √ó Env ‚Üí Env_   
_match-aux([], [], E) = E_    
_match-aux(f, a, E) = {f ‚Ü¶ a} E_  
_match-aux(f :: fl, a :: al, E) = match-aux(fl), al, {f ‚Ü¶ a} E)_   
